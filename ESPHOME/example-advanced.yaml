# EverBlu Meter - Advanced Configuration with Custom Schedule
# This example shows advanced scheduling and monitoring features

esphome:
  name: everblu-meter-advanced

esp32:
  # WARNING: Arduino framework is required; ESP-IDF builds fail because everblu_meter depends on Arduino headers
  board: esp32dev
  framework:
    type: arduino

# WiFi configuration
wifi:
  ssid: "YourWiFiSSID"
  password: "YourWiFiPassword"
  
  # Static IP (optional)
  manual_ip:
    static_ip: 192.168.1.100
    gateway: 192.168.1.1
    subnet: 255.255.255.0

# Enable logging with custom levels
logger:
  level: INFO
  logs:
    everblu_meter: DEBUG
    sensor: WARN

# Enable Home Assistant API
api:
  encryption:
    key: "your-32-byte-base64-encoded-key-here"

# Enable OTA updates
ota:
  password: "YourOTAPassword"

# Web server for diagnostics
web_server:
  port: 80

# Time component with SNTP fallback
time:
  - platform: homeassistant
    id: ha_time
    timezone: Europe/Paris
    on_time_sync:
      then:
        - logger.log: "Time synchronized with Home Assistant"

# EverBlu Meter Component
external_components:
  - source:
      type: git
      url: https://github.com/genestealer/everblu-meters-esp8266-improved
      ref: main
      path: ESPHOME-release
    components: [ everblu_meter ]
    refresh: 1d

everblu_meter:
  id: my_meter
  
  # Meter configuration
  meter_year: 23
  meter_serial: 12345678
  gdo0_pin: 4
  meter_type: water
  
  # Radio configuration - custom frequency
  frequency: 433.82       # Fine-tuned frequency
  auto_scan: false        # Disable auto-scan for faster readings
  debug_cc1101: true      # Enable detailed CC1101 radio debug logs
  
  # Advanced scheduling - weekend only
  reading_schedule: Saturday      # Read only on Saturdays
  read_hour: 6           # Early morning reading (in UTC)
  read_minute: 30
  timezone_offset: 60    # CET (UTC+1) - offset in MINUTES
                         # NOTE: Static offset, update when DST changes (CEST = 120)
  
  # Timing features
  auto_align_time: true
  auto_align_midpoint: false  # Use exact configured time
  
  # Aggressive retry strategy
  max_retries: 15                    # More attempts
  retry_cooldown: 30min              # Shorter cooldown
  
  # Adaptive frequency tracking
  # How many successful reads before adjusting frequency (1 = adjust after each read)
  # Use higher values (5-10) if you have frequent reads and stable conditions
  adaptive_threshold: 1
  
  # Time component
  time_id: ha_time
  
  # Fast updates for monitoring
  update_interval: 30s
  
  # Control buttons
  request_reading_button:
    name: "Read Meter Now"
  frequency_scan_button:
    name: "Scan Frequency"
  reset_frequency_button:
    name: "Reset Frequency Offset"
  
  # Core sensors
  volume:
    id: water_volume
    name: "Water Volume"
    filters:
      - or:
        - throttle: 10s          # Limit updates
        - delta: 0.1             # Only on change

  counter:
    name: "Read Counter"

  battery:
    name: "Meter Battery"
    filters:
      - throttle: 1h             # Battery doesn't change often

  rssi:
    name: "Meter RSSI"

  rssi_percentage:
    name: "Signal Quality"
    filters:
      - sliding_window_moving_average:
          window_size: 5         # Smooth signal readings
          send_every: 1

  lqi:
    name: "LQI"

  lqi_percentage:
    name: "Link Quality"
  
  # Performance metrics
  total_attempts:
    name: "Total Read Attempts"

  successful_reads:
    name: "Successful Reads"

  failed_reads:
    name: "Failed Reads"

  frequency_offset:
    name: "Frequency Offset"

  tuned_frequency:
    name: "Tuned Frequency (MHz)"
  
  frequency_estimate:
    name: "Frequency Estimate"

  meter_serial_sensor:
    name: "Meter Serial"
  meter_year_sensor:
    name: "Meter Year"
  reading_schedule_sensor:
    name: "Reading Schedule"
  reading_time_utc_sensor:
    name: "Reading Time (UTC)"
  
  # Timing sensors (24-hour format: HH:MM)
  time_start:
    name: "Reading Start Time"
  
  time_end:
    name: "Reading End Time"
  
  # Status sensors
  status:
    name: "Meter Status"
    on_value:
      then:
        - if:
            condition:
              text_sensor.state:
                id: meter_status
                state: "Error"
            then:
              - logger.log:
                  level: ERROR
                  format: "Meter reading error detected"
  
  error:
    name: "Last Error"

  radio_state:
    name: "CC1101 State"

  timestamp:
    name: "Last Reading"
  
  history_json:
    name: "Meter History (JSON)"
  
  # Binary sensors
  active_reading:
    id: meter_active_reading
    name: "Reading In Progress"
    on_press:
      then:
        - logger.log: "Meter reading started"
    on_release:
      then:
        - logger.log: "Meter reading completed"
  
  radio_connected:
    name: "CC1101 Connected"

# Template sensor for consumption calculation
sensor:
  - platform: template
    name: "Daily Water Consumption"
    unit_of_measurement: "L"
    device_class: water
    state_class: measurement
    update_interval: 1h
    lambda: |-
      static float last_reading = 0;
      const float current = id(water_volume).state;
      const float consumption = current - last_reading;
      last_reading = current;
      return consumption;
